/**
 * Eta Reduction Optimization Pass
 *
 * Simplifies eta-expansions to point-free style.
 *
 * Example:
 *   (x) => f(x)  →  f  (when x is not free in f)
 *
 * This optimization is particularly useful for cleaning up
 * code generated by the desugarer and making code more concise.
 */

import type { CoreExpr, CoreMatchCase } from "../../types/core-ast.js";

import { freeVars } from "../../utils/ast-analysis.js";
import { OptimizationPass } from "../optimization-pass.js";

export class EtaReductionPass extends OptimizationPass {
    readonly name = "EtaReduction";

    override canApply(expr: CoreExpr): boolean {
        return this.isEtaExpandable(expr);
    }

    override transform(expr: CoreExpr): CoreExpr {
        return this.reduceEta(expr);
    }

    /**
     * Check if an expression is an eta-expansion
     *
     * An eta-expansion has the form: (x) => f(x)
     * where x does not appear free in f
     */
    private isEtaExpandable(expr: CoreExpr): boolean {
        if (expr.kind !== "CoreLambda") {
            return false;
        }

        // Check if lambda parameter is a simple variable pattern
        if (expr.param.kind !== "CoreVarPattern") {
            return false;
        }

        // Check if body is a function application
        if (expr.body.kind !== "CoreApp") {
            return false;
        }

        // Check if the application has exactly one argument
        if (expr.body.args.length !== 1) {
            return false;
        }

        const arg = expr.body.args[0];
        if (!arg) {
            return false;
        }

        // Check if the argument is the parameter variable
        if (arg.kind !== "CoreVar" || arg.name !== expr.param.name) {
            return false;
        }

        // Check that the parameter is not free in the function being called
        const freeInFunc = freeVars(expr.body.func);
        if (freeInFunc.has(expr.param.name)) {
            return false;
        }

        return true;
    }

    /**
     * Perform eta reduction recursively on an expression
     */
    private reduceEta(expr: CoreExpr): CoreExpr {
        // First, recursively reduce children
        const reduced = this.reduceChildren(expr);

        // Then check if the result is eta-expandable
        if (this.isEtaExpandable(reduced)) {
            // Perform eta reduction: (x) => f(x)  →  f
            if (reduced.kind === "CoreLambda" && reduced.body.kind === "CoreApp") {
                return reduced.body.func;
            }
        }

        return reduced;
    }

    /**
     * Recursively reduce children of an expression
     */
    private reduceChildren(expr: CoreExpr): CoreExpr {
        switch (expr.kind) {
            // Literals and variables - no children
            case "CoreIntLit":
            case "CoreFloatLit":
            case "CoreStringLit":
            case "CoreBoolLit":
            case "CoreUnitLit":
            case "CoreVar":
                return expr;

            // Let binding
            case "CoreLet":
                return {
                    ...expr,
                    value: this.reduceEta(expr.value),
                    body: this.reduceEta(expr.body),
                };

            // Let rec
            case "CoreLetRecExpr":
                return {
                    ...expr,
                    bindings: expr.bindings.map((binding) => ({
                        ...binding,
                        value: this.reduceEta(binding.value),
                    })),
                    body: this.reduceEta(expr.body),
                };

            // Lambda - this is where eta reduction happens
            case "CoreLambda":
                return {
                    ...expr,
                    body: this.reduceEta(expr.body),
                };

            // Application
            case "CoreApp":
                return {
                    ...expr,
                    func: this.reduceEta(expr.func),
                    args: expr.args.map((arg) => this.reduceEta(arg)),
                };

            // Match
            case "CoreMatch":
                return {
                    ...expr,
                    expr: this.reduceEta(expr.expr),
                    cases: expr.cases.map((c) => {
                        const optimizedCase: CoreMatchCase = {
                            pattern: c.pattern,
                            body: this.reduceEta(c.body),
                            loc: c.loc,
                        };
                        if (c.guard !== undefined) {
                            optimizedCase.guard = this.reduceEta(c.guard);
                        }
                        return optimizedCase;
                    }),
                };

            // Record
            case "CoreRecord":
                return {
                    ...expr,
                    fields: expr.fields.map((field) => {
                        if (field.kind === "Field") {
                            return {
                                ...field,
                                value: this.reduceEta(field.value),
                            };
                        } else {
                            return {
                                ...field,
                                expr: this.reduceEta(field.expr),
                            };
                        }
                    }),
                };

            // Record access
            case "CoreRecordAccess":
                return {
                    ...expr,
                    record: this.reduceEta(expr.record),
                };

            // Record update
            case "CoreRecordUpdate":
                return {
                    ...expr,
                    record: this.reduceEta(expr.record),
                    updates: expr.updates.map((update) => {
                        if (update.kind === "Field") {
                            return {
                                ...update,
                                value: this.reduceEta(update.value),
                            };
                        } else {
                            return {
                                ...update,
                                expr: this.reduceEta(update.expr),
                            };
                        }
                    }),
                };

            // Variant
            case "CoreVariant":
                return {
                    ...expr,
                    args: expr.args.map((arg) => this.reduceEta(arg)),
                };

            // Binary operation
            case "CoreBinOp":
                return {
                    ...expr,
                    left: this.reduceEta(expr.left),
                    right: this.reduceEta(expr.right),
                };

            // Unary operation
            case "CoreUnaryOp":
                return {
                    ...expr,
                    expr: this.reduceEta(expr.expr),
                };

            // Type annotation
            case "CoreTypeAnnotation":
                return {
                    ...expr,
                    expr: this.reduceEta(expr.expr),
                };

            // Unsafe block - don't optimize inside
            case "CoreUnsafe":
                return expr;

            // Tuple
            case "CoreTuple":
                return {
                    ...expr,
                    elements: expr.elements.map((e) => this.reduceEta(e)),
                };
        }
    }
}
