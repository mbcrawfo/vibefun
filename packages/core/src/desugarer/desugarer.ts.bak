/**
 * Desugarer - transforms Surface AST to Core AST
 *
 * This module eliminates all syntactic sugar from the Surface AST, producing
 * a simplified Core AST that's easier for the type checker and code generator
 * to process.
 *
 * Transformations performed:
 * - Multi-parameter lambdas → Single-parameter curried lambdas
 * - Pipe operator → Function application
 * - If-then-else → Match on boolean
 * - Block expressions → Nested let bindings
 * - List literals → Cons/Nil variants
 * - List cons operator → Cons variant
 * - Record updates → Explicit field copying
 * - Function composition → Lambda wrapping
 * - Or-patterns → Multiple match cases
 * - External blocks → Multiple external declarations
 */

import type {
    BinaryOp,
    Declaration,
    Expr,
    ListElement,
    Location,
    Module,
    Pattern,
    RecordTypeField,
    TypeDefinition,
    TypeExpr,
    VariantConstructor,
} from "../types/ast.js";
import type {
    CoreBinaryOp,
    CoreDeclaration,
    CoreExpr,
    CoreExternalDecl,
    CoreImportDecl,
    CoreImportItem,
    CoreMatchCase,
    CoreModule,
    CorePattern,
    CoreRecordTypeField,
    CoreTypeDefinition,
    CoreTypeExpr,
    CoreVariantConstructor,
} from "../types/core-ast.js";

import { DesugarError } from "./DesugarError.js";
import { FreshVarGen } from "./FreshVarGen.js";
import { desugarPipe as desugarPipeImpl } from "./desugarPipe.js";
import { buildConsChain as buildConsChainImpl } from "./buildConsChain.js";
import { desugarRecordTypeField as desugarRecordTypeFieldImpl } from "./desugarRecordTypeField.js";
import { desugarVariantConstructor as desugarVariantConstructorImpl } from "./desugarVariantConstructor.js";
import { desugarBlock as desugarBlockImpl } from "./desugarBlock.js";
import { curryLambda as curryLambdaImpl } from "./curryLambda.js";
import { desugarComposition as desugarCompositionImpl } from "./desugarComposition.js";
import { desugarListLiteral as desugarListLiteralImpl } from "./desugarListLiteral.js";
import { desugarListWithConcats as desugarListWithConcatsImpl } from "./desugarListWithConcats.js";
import { desugarListPattern as desugarListPatternImpl } from "./desugarListPattern.js";
import { desugarBinOp as desugarBinOpImpl } from "./desugarBinOp.js";
import { desugarTypeExpr as desugarTypeExprImpl } from "./desugarTypeExpr.js";
import { desugarTypeDefinition as desugarTypeDefinitionImpl } from "./desugarTypeDefinition.js";

// Re-export for backwards compatibility
export { DesugarError, FreshVarGen };

/**
 * Desugar a block expression into nested let bindings
 */
function desugarBlock(exprs: Expr[], loc: Location, gen: FreshVarGen): CoreExpr {
    return desugarBlockImpl(exprs, loc, gen, desugar, desugarPattern);
}

/**
 * Curry a multi-parameter lambda into nested single-parameter lambdas
 */
function curryLambda(params: Pattern[], body: Expr, loc: Location, gen: FreshVarGen): CoreExpr {
    return curryLambdaImpl(params, body, loc, gen, desugar, desugarPattern);
}

/**
 * Desugar a pipe operator into function application
 */
function desugarPipe(data: Expr, func: Expr, loc: Location, gen: FreshVarGen): CoreExpr {
    return desugarPipeImpl(data, func, loc, gen, desugar);
}

/**
 * Desugar function composition operators
 */
function desugarComposition(
    op: "ForwardCompose" | "BackwardCompose",
    left: Expr,
    right: Expr,
    loc: Location,
    gen: FreshVarGen,
): CoreExpr {
    return desugarCompositionImpl(op, left, right, loc, gen, desugar);
}

/**
 * Desugar a list literal into Cons/Nil chain or concat operations
 *
 * @param elements - List elements (may include spread elements)
 * @param loc - Location of the list literal
 * @param gen - Fresh variable generator
 * @returns Desugared core expression
 *
 * @example
 * // Input: [1, 2, 3]
 * // Output: Cons(1, Cons(2, Cons(3, Nil)))
 *
 * @example
 * // Input: [1, 2, ...rest]
 * // Output: Cons(1, Cons(2, rest))
 *
 * @example
 * // Input: [...xs, 1, ...ys]
 * // Output: concat(xs, Cons(1, ys))
 */
function desugarListLiteral(elements: ListElement[], loc: Location, gen: FreshVarGen): CoreExpr {
    return desugarListLiteralImpl(elements, loc, gen, desugar, buildConsChain, desugarListWithConcats);
}

/**
 * Build a simple Cons chain from regular elements
 */
function buildConsChain(elements: { kind: "Element"; expr: Expr }[], loc: Location, gen: FreshVarGen): CoreExpr {
    return buildConsChainImpl(elements, loc, gen, desugar);
}

/**
 * Desugar list with spreads using concat
 *
 * Groups elements into segments separated by spreads, then concat them together.
 */
function desugarListWithConcats(elements: ListElement[], loc: Location, gen: FreshVarGen): CoreExpr {
    // Group elements into segments
    const segments: CoreExpr[] = [];
    let currentSegment: { kind: "Element"; expr: Expr }[] = [];

    for (const elem of elements) {
        if (elem.kind === "Element") {
            currentSegment.push(elem);
        } else {
            // Spread element
            // First, flush current segment if not empty
            if (currentSegment.length > 0) {
                segments.push(buildConsChain(currentSegment, loc, gen));
                currentSegment = [];
            }
            // Add the spread expression directly
            segments.push(desugar(elem.expr, gen));
        }
    }

    // Flush final segment
    if (currentSegment.length > 0) {
        segments.push(buildConsChain(currentSegment, loc, gen));
    }

    if (segments.length === 0) {
        // Empty list
        return {
            kind: "CoreVariant",
            constructor: "Nil",
            args: [],
            loc,
        };
    }

    if (segments.length === 1) {
        // Single segment
        const segment = segments[0];
        if (!segment) {
            throw new DesugarError("Empty segment in list", loc);
        }
        return segment;
    }

    // Multiple segments - concat them together from right to left
    let result = segments[segments.length - 1];
    if (!result) {
        throw new DesugarError("Empty final segment", loc);
    }

    for (let i = segments.length - 2; i >= 0; i--) {
        const segment = segments[i];
        if (!segment) {
            throw new DesugarError(`Empty segment at index ${i}`, loc);
        }

        // concat(segment, result)
        result = {
            kind: "CoreApp",
            func: { kind: "CoreVar", name: "concat", loc },
            args: [segment, result],
            loc,
        };
    }

    return result;
}

/**
 * Desugar a surface expression to a core expression
 *
 * @param expr - Surface expression to desugar
 * @param gen - Fresh variable generator (optional, created if not provided)
 * @returns Desugared core expression
 * @throws {DesugarError} If desugaring fails
 *
 * @example
 * const surfaceExpr = { kind: "IntLit", value: 42, loc };
 * const coreExpr = desugar(surfaceExpr);
 * // => { kind: "CoreIntLit", value: 42, loc }
 */
export function desugar(expr: Expr, gen: FreshVarGen = new FreshVarGen()): CoreExpr {
    switch (expr.kind) {
        // Literals - direct translation
        case "IntLit":
            return {
                kind: "CoreIntLit",
                value: expr.value,
                loc: expr.loc,
            };

        case "FloatLit":
            return {
                kind: "CoreFloatLit",
                value: expr.value,
                loc: expr.loc,
            };

        case "StringLit":
            return {
                kind: "CoreStringLit",
                value: expr.value,
                loc: expr.loc,
            };

        case "BoolLit":
            return {
                kind: "CoreBoolLit",
                value: expr.value,
                loc: expr.loc,
            };

        case "UnitLit":
            return {
                kind: "CoreUnitLit",
                loc: expr.loc,
            };

        // Variables - direct translation
        case "Var":
            return {
                kind: "CoreVar",
                name: expr.name,
                loc: expr.loc,
            };

        // Let bindings - desugar value and body
        case "Let":
            return {
                kind: "CoreLet",
                pattern: desugarPattern(expr.pattern, gen),
                value: desugar(expr.value, gen),
                body: desugar(expr.body, gen),
                mutable: expr.mutable,
                recursive: expr.recursive,
                loc: expr.loc,
            };

        // Lambdas - curry multi-parameter lambdas
        case "Lambda":
            return curryLambda(expr.params, expr.body, expr.loc, gen);

        // Function application - desugar function and arguments
        case "App":
            return {
                kind: "CoreApp",
                func: desugar(expr.func, gen),
                args: expr.args.map((arg) => desugar(arg, gen)),
                loc: expr.loc,
            };

        // If-then-else - desugar to match on boolean
        case "If":
            return {
                kind: "CoreMatch",
                expr: desugar(expr.condition, gen),
                cases: [
                    {
                        pattern: {
                            kind: "CoreLiteralPattern",
                            literal: true,
                            loc: expr.loc,
                        },
                        body: desugar(expr.then, gen),
                        loc: expr.loc,
                    },
                    {
                        pattern: {
                            kind: "CoreLiteralPattern",
                            literal: false,
                            loc: expr.loc,
                        },
                        body: desugar(expr.else_, gen),
                        loc: expr.loc,
                    },
                ],
                loc: expr.loc,
            };

        // Match - desugar expression and cases, expanding or-patterns
        case "Match":
            return {
                kind: "CoreMatch",
                expr: desugar(expr.expr, gen),
                cases: expr.cases.flatMap((matchCase) => {
                    // If pattern is OrPattern, expand into multiple cases
                    if (matchCase.pattern.kind === "OrPattern") {
                        return matchCase.pattern.patterns.map((altPattern) => {
                            const coreCase: CoreMatchCase = {
                                pattern: desugarPattern(altPattern, gen),
                                body: desugar(matchCase.body, gen),
                                loc: matchCase.loc,
                            };
                            if (matchCase.guard) {
                                coreCase.guard = desugar(matchCase.guard, gen);
                            }
                            return coreCase;
                        });
                    }

                    // Regular pattern - just desugar normally
                    const coreCase: CoreMatchCase = {
                        pattern: desugarPattern(matchCase.pattern, gen),
                        body: desugar(matchCase.body, gen),
                        loc: matchCase.loc,
                    };
                    if (matchCase.guard) {
                        coreCase.guard = desugar(matchCase.guard, gen);
                    }
                    return [coreCase];
                }),
                loc: expr.loc,
            };

        // Records - desugar field values
        case "Record":
            return {
                kind: "CoreRecord",
                fields: expr.fields.map((field) => ({
                    name: field.name,
                    value: desugar(field.value, gen),
                    loc: field.loc,
                })),
                loc: expr.loc,
            };

        // Record access - desugar record expression
        case "RecordAccess":
            return {
                kind: "CoreRecordAccess",
                record: desugar(expr.record, gen),
                field: expr.field,
                loc: expr.loc,
            };

        // Record update - desugar to CoreRecordUpdate
        case "RecordUpdate":
            return {
                kind: "CoreRecordUpdate",
                record: desugar(expr.record, gen),
                updates: expr.updates.map((field) => ({
                    name: field.name,
                    value: desugar(field.value, gen),
                    loc: field.loc,
                })),
                loc: expr.loc,
            };

        // List literals - desugar to Cons/Nil
        case "List":
            return desugarListLiteral(expr.elements, expr.loc, gen);

        // List cons operator - desugar to Cons variant
        case "ListCons":
            return {
                kind: "CoreVariant",
                constructor: "Cons",
                args: [desugar(expr.head, gen), desugar(expr.tail, gen)],
                loc: expr.loc,
            };

        // Binary operations
        case "BinOp":
            return desugarBinOp(expr.op, expr.left, expr.right, expr.loc, gen);

        // Unary operations - desugar operand
        case "UnaryOp":
            return {
                kind: "CoreUnaryOp",
                op: expr.op,
                expr: desugar(expr.expr, gen),
                loc: expr.loc,
            };

        // Pipe operator - desugar to function application
        case "Pipe":
            return desugarPipe(expr.expr, expr.func, expr.loc, gen);

        // Block expressions - desugar to nested lets
        case "Block":
            return desugarBlock(expr.exprs, expr.loc, gen);

        // Type annotation - preserve, desugar inner expression
        case "TypeAnnotation":
            return {
                kind: "CoreTypeAnnotation",
                expr: desugar(expr.expr, gen),
                typeExpr: desugarTypeExpr(expr.typeExpr),
                loc: expr.loc,
            };

        // Unsafe block - preserve boundary, desugar contents
        case "Unsafe":
            return {
                kind: "CoreUnsafe",
                expr: desugar(expr.expr, gen),
                loc: expr.loc,
            };

        default:
            // Should never reach here if all cases are covered
            throw new DesugarError(
                `Unknown expression kind: ${(expr as Expr).kind}`,
                (expr as Expr).loc,
                "This may indicate a parser bug or missing desugaring implementation",
            );
    }
}

/**
 * Desugar a binary operation
 */
function desugarBinOp(op: BinaryOp, left: Expr, right: Expr, loc: Location, gen: FreshVarGen): CoreExpr {
    // Handle composition operators specially
    if (op === "ForwardCompose" || op === "BackwardCompose") {
        return desugarComposition(op, left, right, loc, gen);
    }

    // Cons operator is handled in the ListCons case above
    // If we get here with Cons, it shouldn't happen
    if (op === "Cons") {
        throw new DesugarError(
            "Cons operator should be handled by ListCons expression",
            loc,
            "This may indicate a parser bug",
        );
    }

    // All other binary operators are preserved
    return {
        kind: "CoreBinOp",
        op: op as CoreBinaryOp, // Type assertion safe - we excluded composition and cons
        left: desugar(left, gen),
        right: desugar(right, gen),
        loc,
    };
}

/**
 * Desugar a list pattern into Cons/Nil patterns
 *
 * @param elements - Pattern elements
 * @param rest - Optional rest pattern
 * @param loc - Location of the list pattern
 * @param gen - Fresh variable generator
 * @returns Desugared core pattern
 *
 * @example
 * // Input: [] => Nil
 * // Input: [x] => Cons(x, Nil)
 * // Input: [x, ...rest] => Cons(x, rest)
 */
function desugarListPattern(
    elements: Pattern[],
    rest: Pattern | undefined,
    loc: Location,
    gen: FreshVarGen,
): CorePattern {
    // Empty list pattern: []
    if (elements.length === 0 && !rest) {
        return {
            kind: "CoreVariantPattern",
            constructor: "Nil",
            args: [],
            loc,
        };
    }

    // Just rest pattern: [...rest]
    if (elements.length === 0 && rest) {
        return desugarPattern(rest, gen);
    }

    // Build Cons patterns from right to left
    // Start with either rest pattern or Nil
    let tailPattern: CorePattern;

    if (rest) {
        tailPattern = desugarPattern(rest, gen);
    } else {
        tailPattern = {
            kind: "CoreVariantPattern",
            constructor: "Nil",
            args: [],
            loc,
        };
    }

    // Work backwards through elements to build nested Cons patterns
    for (let i = elements.length - 1; i >= 0; i--) {
        const element = elements[i];
        if (!element) {
            throw new DesugarError(`List pattern has undefined element at index ${i}`, loc);
        }

        tailPattern = {
            kind: "CoreVariantPattern",
            constructor: "Cons",
            args: [desugarPattern(element, gen), tailPattern],
            loc,
        };
    }

    return tailPattern;
}

/**
 * Desugar a pattern
 *
 * @param pattern - Surface pattern to desugar
 * @param gen - Fresh variable generator
 * @returns Desugared core pattern
 */
export function desugarPattern(pattern: Pattern, gen: FreshVarGen): CorePattern {
    switch (pattern.kind) {
        case "VarPattern":
            return {
                kind: "CoreVarPattern",
                name: pattern.name,
                loc: pattern.loc,
            };

        case "WildcardPattern":
            return {
                kind: "CoreWildcardPattern",
                loc: pattern.loc,
            };

        case "LiteralPattern":
            return {
                kind: "CoreLiteralPattern",
                literal: pattern.literal,
                loc: pattern.loc,
            };

        case "ConstructorPattern":
            return {
                kind: "CoreVariantPattern",
                constructor: pattern.constructor,
                args: pattern.args.map((arg) => desugarPattern(arg, gen)),
                loc: pattern.loc,
            };

        case "RecordPattern":
            return {
                kind: "CoreRecordPattern",
                fields: pattern.fields.map((field) => ({
                    name: field.name,
                    pattern: desugarPattern(field.pattern, gen),
                    loc: field.loc,
                })),
                loc: pattern.loc,
            };

        case "ListPattern":
            return desugarListPattern(pattern.elements, pattern.rest, pattern.loc, gen);

        case "OrPattern":
            // Or-patterns should be expanded at the Match level before reaching here
            throw new DesugarError(
                "Or-pattern should have been expanded at match level",
                pattern.loc,
                "This is an internal compiler error - or-patterns must be expanded before pattern desugaring",
            );

        default:
            throw new DesugarError(
                `Unknown pattern kind: ${(pattern as Pattern).kind}`,
                (pattern as Pattern).loc,
                "This may indicate a parser bug",
            );
    }
}

/**
 * Desugar a type expression
 *
 * Type expressions are structurally similar between surface and core AST,
 * but we need to properly transform the kind names and recursively process
 * nested type expressions.
 *
 * @param typeExpr - Surface type expression
 * @returns Core type expression
 */
function desugarTypeExpr(typeExpr: TypeExpr): CoreTypeExpr {
    switch (typeExpr.kind) {
        case "TypeVar":
            return {
                kind: "CoreTypeVar",
                name: typeExpr.name,
                loc: typeExpr.loc,
            };

        case "TypeConst":
            return {
                kind: "CoreTypeConst",
                name: typeExpr.name,
                loc: typeExpr.loc,
            };

        case "TypeApp":
            return {
                kind: "CoreTypeApp",
                constructor: desugarTypeExpr(typeExpr.constructor),
                args: typeExpr.args.map(desugarTypeExpr),
                loc: typeExpr.loc,
            };

        case "FunctionType":
            return {
                kind: "CoreFunctionType",
                params: typeExpr.params.map(desugarTypeExpr),
                return_: desugarTypeExpr(typeExpr.return_),
                loc: typeExpr.loc,
            };

        case "RecordType":
            return {
                kind: "CoreRecordType",
                fields: typeExpr.fields.map(desugarRecordTypeField),
                loc: typeExpr.loc,
            };

        case "VariantType":
            return {
                kind: "CoreVariantType",
                constructors: typeExpr.constructors.map(desugarVariantConstructor),
                loc: typeExpr.loc,
            };

        case "UnionType":
            return {
                kind: "CoreUnionType",
                types: typeExpr.types.map(desugarTypeExpr),
                loc: typeExpr.loc,
            };
    }
}

/**
 * Desugar a record type field
 */
function desugarRecordTypeField(field: RecordTypeField): CoreRecordTypeField {
    return desugarRecordTypeFieldImpl(field, desugarTypeExpr);
}

/**
 * Desugar a variant constructor
 */
function desugarVariantConstructor(ctor: VariantConstructor): CoreVariantConstructor {
    return desugarVariantConstructorImpl(ctor, desugarTypeExpr);
}

/**
 * Desugar a declaration
 *
 * @param decl - Surface declaration to desugar
 * @param gen - Fresh variable generator
 * @returns Desugared core declaration(s)
 */
export function desugarDecl(decl: Declaration, gen: FreshVarGen): CoreDeclaration | CoreDeclaration[] {
    switch (decl.kind) {
        case "LetDecl":
            return {
                kind: "CoreLetDecl",
                pattern: desugarPattern(decl.pattern, gen),
                value: desugar(decl.value, gen),
                mutable: decl.mutable,
                recursive: decl.recursive,
                exported: decl.exported,
                loc: decl.loc,
            };

        case "TypeDecl":
            // Type declarations pass through (no desugaring needed)
            return {
                kind: "CoreTypeDecl",
                name: decl.name,
                params: decl.params,
                definition: desugarTypeDefinition(decl.definition),
                exported: decl.exported,
                loc: decl.loc,
            };

        case "ExternalDecl": {
            // External declarations pass through
            const coreDecl: CoreExternalDecl = {
                kind: "CoreExternalDecl",
                name: decl.name,
                typeExpr: desugarTypeExpr(decl.typeExpr),
                jsName: decl.jsName,
                exported: decl.exported,
                loc: decl.loc,
            };
            if (decl.from) {
                coreDecl.from = decl.from;
            }
            return coreDecl;
        }

        case "ExternalTypeDecl":
            return {
                kind: "CoreExternalTypeDecl",
                name: decl.name,
                typeExpr: desugarTypeExpr(decl.typeExpr),
                exported: decl.exported,
                loc: decl.loc,
            };

        case "ExternalBlock":
            // Expand external block into individual declarations
            return decl.items.map((item) => {
                if (item.kind === "ExternalValue") {
                    const coreDecl: CoreExternalDecl = {
                        kind: "CoreExternalDecl",
                        name: item.name,
                        typeExpr: desugarTypeExpr(item.typeExpr),
                        jsName: item.jsName,
                        exported: decl.exported,
                        loc: item.loc,
                    };
                    if (decl.from) {
                        coreDecl.from = decl.from;
                    }
                    return coreDecl;
                } else {
                    // ExternalType
                    return {
                        kind: "CoreExternalTypeDecl",
                        name: item.name,
                        typeExpr: desugarTypeExpr(item.typeExpr),
                        exported: decl.exported,
                        loc: item.loc,
                    };
                }
            });

        case "ImportDecl":
            // Import declarations pass through
            return {
                kind: "CoreImportDecl",
                items: decl.items.map((item): CoreImportItem => {
                    const coreItem: CoreImportItem = {
                        name: item.name,
                        isType: item.isType,
                    };
                    if (item.alias) {
                        coreItem.alias = item.alias;
                    }
                    return coreItem;
                }),
                from: decl.from,
                loc: decl.loc,
            };

        default:
            throw new DesugarError(
                `Unknown declaration kind: ${(decl as Declaration).kind}`,
                (decl as Declaration).loc,
                "This may indicate a parser bug",
            );
    }
}

/**
 * Desugar a type definition
 *
 * Type definitions are structurally similar between surface and core AST,
 * but we need to properly transform the kind names and recursively process
 * nested type expressions.
 *
 * @param def - Surface type definition
 * @returns Core type definition
 */
function desugarTypeDefinition(def: TypeDefinition): CoreTypeDefinition {
    switch (def.kind) {
        case "AliasType":
            return {
                kind: "CoreAliasType",
                typeExpr: desugarTypeExpr(def.typeExpr),
                loc: def.loc,
            };

        case "RecordTypeDef":
            return {
                kind: "CoreRecordTypeDef",
                fields: def.fields.map(desugarRecordTypeField),
                loc: def.loc,
            };

        case "VariantTypeDef":
            return {
                kind: "CoreVariantTypeDef",
                constructors: def.constructors.map(desugarVariantConstructor),
                loc: def.loc,
            };
    }
}

/**
 * Desugar a module
 *
 * @param module - Surface module to desugar
 * @returns Desugared core module
 */
export function desugarModule(module: Module): CoreModule {
    const gen = new FreshVarGen();

    // Extract imports (they're in the declarations array)
    const imports: CoreImportDecl[] = [];
    const declarations: CoreDeclaration[] = [];

    for (const decl of [...module.imports, ...module.declarations]) {
        const desugared = desugarDecl(decl, gen);

        if (Array.isArray(desugared)) {
            // External blocks can expand to multiple declarations
            declarations.push(...desugared);
        } else if (desugared.kind === "CoreImportDecl") {
            imports.push(desugared);
        } else {
            declarations.push(desugared);
        }
    }

    return {
        imports,
        declarations,
        loc: module.loc,
    };
}
