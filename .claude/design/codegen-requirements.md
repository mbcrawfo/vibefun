# Vibefun Code Generator Requirements

## 1. Overview

This document specifies the requirements for the vibefun code generator, which transforms a `TypedModule` (the output of the type checker) into executable JavaScript.

### 1.1 Purpose

The code generator is the final phase of the compilation pipeline:

```
Source → Lexer → Parser → Desugarer → TypeChecker → Optimizer → CodeGen → JavaScript
```

It produces readable, ES2020-compliant JavaScript that correctly implements vibefun semantics.

### 1.2 Design Goals

1. **Correctness**: Generated code must faithfully implement vibefun semantics
2. **Readability**: Output should be human-readable for debugging
3. **Modularity**: Architecture must support multiple output targets in the future
4. **Performance**: Generated code should be reasonably efficient

---

## 2. Input/Output Contract

### 2.1 Input: TypedModule

```typescript
interface TypedModule {
    module: CoreModule;                    // Desugared AST
    env: TypeEnv;                          // Type environment
    declarationTypes: Map<string, Type>;   // Inferred types for declarations
}
```

**CoreModule structure:**
- `imports: CoreImportDecl[]` - Import declarations
- `declarations: CoreDeclaration[]` - Top-level declarations
- `loc: Location` - Source location

**TypeEnv provides:**
- Value bindings (including external declarations with `jsName` and `from` properties)
- Type bindings (for variant constructor information)

### 2.2 Output: GenerateResult

```typescript
interface GenerateResult {
    readonly code: string;     // Generated JavaScript
    // Future: readonly sourceMap?: SourceMap;
}
```

### 2.3 Current Interface

```typescript
interface GenerateOptions {
    readonly filename?: string;  // For output comments
    // Future extensions:
    // readonly target?: "es2020" | "es2022" | "esnext";
    // readonly sourceMap?: boolean;
    // readonly runtimeChecks?: "ffi" | "all" | "none";
}

function generate(typedModule: TypedModule, options?: GenerateOptions): GenerateResult
```

---

## 3. JavaScript Target Specification

### 3.1 ES2020 Baseline (Initial Implementation)

The initial implementation targets ES2020. Generated code may use:
- `const` and `let` declarations
- Arrow functions
- Destructuring assignment and parameters
- Spread operator (`...`)
- Template literals
- `===` strict equality
- ES6 modules (`import`/`export`)

### 3.2 Output Format

- **Module format**: ES6 modules (not CommonJS)
- **File extension**: Output files should be `.js`
- **Exports**: Collected at end of file for clarity
- **Imports**: At top of file, after header comment

### 3.3 Header Comment

Generated files should include a header:
```javascript
// Generated by Vibefun compiler
// Source: <filename>
```

---

## 4. Runtime Value Representations

### 4.1 Primitive Types

| Vibefun Type | JavaScript Representation |
|--------------|--------------------------|
| `Int` | `number` (safe integer range) |
| `Float` | `number` (IEEE 754 double) |
| `String` | `string` (UTF-16) |
| `Bool` | `boolean` |
| `Unit` | `undefined` |

### 4.2 Records

**Representation:** Plain JavaScript objects

```vibefun
let person = { name: "Alice", age: 30 };
```
```javascript
const person = { name: "Alice", age: 30 };
```

**Field access:**
```vibefun
person.name
```
```javascript
person.name
```

**Record update (spread):**
```vibefun
{ ...person, age: 31 }
```
```javascript
{ ...person, age: 31 }
```

### 4.3 Variants (Algebraic Data Types)

**Representation:** Tagged objects with `$tag` property

| Constructor | JavaScript |
|-------------|------------|
| No args: `None` | `{ $tag: "None" }` |
| Single arg: `Some(x)` | `{ $tag: "Some", $0: x }` |
| Multiple args: `Cons(h, t)` | `{ $tag: "Cons", $0: h, $1: t }` |

**Rationale for `$tag`:** Using `$` prefix avoids collision with user field names while remaining valid JS.

**Constructor functions:**
```javascript
const Some = ($0) => ({ $tag: "Some", $0 });
const None = { $tag: "None" };
const Cons = ($0) => ($1) => ({ $tag: "Cons", $0, $1 });
const Nil = { $tag: "Nil" };
```

### 4.4 Lists

Lists use the Cons/Nil variant representation:
```javascript
// [1, 2, 3] compiles to:
Cons(1)(Cons(2)(Cons(3)(Nil)))
```

### 4.5 Tuples

**Representation:** JavaScript arrays

```vibefun
let triple = (1, "hello", true);
```
```javascript
const triple = [1, "hello", true];
```

### 4.6 Mutable References (Ref<T>)

**Representation:** Objects with `$value` property

```vibefun
let mut counter = ref(0);  // Create
let value = !counter;      // Dereference
counter := 5;              // Assign
```
```javascript
const counter = { $value: 0 };
const value = counter.$value;
counter.$value = 5;
```

### 4.7 Functions

All functions are curried (single parameter):

```vibefun
let add = (x, y) => x + y;
```
```javascript
const add = (x) => (y) => x + y;
```

**Note:** The desugarer already converts multi-param lambdas to nested single-param lambdas, so `CoreLambda` always has exactly one parameter.

---

## 5. Expression Compilation Rules

### 5.1 Literals

| Core AST | JavaScript |
|----------|------------|
| `CoreIntLit { value: 42 }` | `42` |
| `CoreFloatLit { value: 3.14 }` | `3.14` |
| `CoreStringLit { value: "hi" }` | `"hi"` |
| `CoreBoolLit { value: true }` | `true` |
| `CoreUnitLit` | `undefined` |

**String escaping:** Strings must be properly escaped for JavaScript (quotes, backslashes, newlines, etc.).

### 5.2 Variables

| Core AST | JavaScript |
|----------|------------|
| `CoreVar { name: "x" }` | `x` (or escaped if reserved) |

### 5.3 Let Bindings (CoreLet)

**Simple binding:**
```javascript
// let x = expr in body
((x) => body)(expr)
// Or using IIFE with const:
(() => { const x = expr; return body; })()
```

**Preferred approach:** Use statement-level `const` when at declaration level:
```javascript
const x = expr;
```

**Pattern bindings:** Destructure according to pattern:
```javascript
const { name, age } = person;
const [first, second] = tuple;
```

### 5.4 Recursive Bindings (CoreLet with recursive: true)

For self-recursive functions:
```javascript
const factorial = (n) => n <= 1 ? 1 : n * factorial(n - 1);
```

### 5.5 Mutually Recursive Bindings (CoreLetRecExpr)

```javascript
const isEven = (n) => n === 0 ? true : isOdd(n - 1);
const isOdd = (n) => n === 0 ? false : isEven(n - 1);
```

**Note:** JavaScript hoisting handles forward references to functions.

### 5.6 Lambdas (CoreLambda)

```javascript
(param) => body
```

**Pattern parameters:** Destructure in parameter position:
```javascript
({ name, age }) => name
([head, ...tail]) => head
```

### 5.7 Function Application (CoreApp)

**Single argument:**
```javascript
func(arg)
```

**Multiple arguments (curried):**
```javascript
func(arg1)(arg2)(arg3)
```

### 5.8 Match Expressions (CoreMatch)

Pattern matching compiles to conditional chains. The generated code must:
- Evaluate the scrutinee exactly once
- Test patterns top-to-bottom (first match wins)
- Evaluate guards after pattern match, before body
- Bind pattern variables in scope for guard and body

**Example compilation:**
```vibefun
match value {
    | 0 => "zero"
    | n when n > 0 => "positive"
    | _ => "negative"
}
```
```javascript
(($match) => {
    if ($match === 0) return "zero";
    { const n = $match; if (n > 0) return "positive"; }
    return "negative";
})(value)
```

**Variant matching:**
```vibefun
match opt {
    | Some(x) => x
    | None => 0
}
```
```javascript
(($match) => {
    if ($match.$tag === "Some") { const x = $match.$0; return x; }
    if ($match.$tag === "None") return 0;
})($opt)
```

### 5.9 Records

**Construction:**
```javascript
{ field1: value1, field2: value2 }
```

**Field access:**
```javascript
record.field
```

**Update (CoreRecordUpdate):**
```javascript
{ ...record, field: newValue }
```

**Spread fields:** Preserve spread in output:
```javascript
{ ...base, extra: value }
```

### 5.10 Variants (CoreVariant)

Use constructor functions or object literals:
```javascript
// Some(42)
{ $tag: "Some", $0: 42 }
// Or if constructor function exists:
Some(42)
```

### 5.11 Binary Operators (CoreBinOp)

| Core Op | JavaScript | Notes |
|---------|------------|-------|
| `Add` | `a + b` | |
| `Subtract` | `a - b` | |
| `Multiply` | `a * b` | |
| `Divide` | `a / b` | For Int, use `Math.trunc(a / b)` |
| `Modulo` | `a % b` | |
| `Equal` | `a === b` | See equality section |
| `NotEqual` | `a !== b` | See equality section |
| `LessThan` | `a < b` | |
| `LessEqual` | `a <= b` | |
| `GreaterThan` | `a > b` | |
| `GreaterEqual` | `a >= b` | |
| `LogicalAnd` | `a && b` | Short-circuit preserved |
| `LogicalOr` | `a \|\| b` | Short-circuit preserved |
| `Concat` | `a + b` | String concatenation |
| `RefAssign` | `a.$value = b` | Returns undefined |

**Integer division:** Must truncate toward zero:
```javascript
Math.trunc(a / b)
```

**Short-circuit operators:** Must preserve short-circuit semantics. The generated code must not evaluate the right operand if the left determines the result.

### 5.12 Unary Operators (CoreUnaryOp)

| Core Op | JavaScript |
|---------|------------|
| `Negate` | `-expr` |
| `LogicalNot` | `!expr` |
| `Deref` | `expr.$value` |

### 5.13 Tuples (CoreTuple)

```javascript
[element0, element1, element2]
```

### 5.14 Type Annotations (CoreTypeAnnotation)

Compile the inner expression only (annotations are erased at runtime):
```javascript
// (expr : Type) compiles to just:
expr
```

### 5.15 Unsafe Blocks (CoreUnsafe)

Compile the inner expression (the unsafe marker is erased):
```javascript
// unsafe { expr } compiles to:
expr
```

---

## 6. Pattern Compilation Rules

### 6.1 Pattern Types

| Pattern | Test | Binding |
|---------|------|---------|
| `CoreWildcardPattern` | None (always matches) | None |
| `CoreVarPattern { name }` | None (always matches) | `const name = value;` |
| `CoreLiteralPattern { literal: n }` | `value === n` | None |
| `CoreVariantPattern { constructor, args }` | `value.$tag === "Ctor"` | Destructure `$0`, `$1`, etc. |
| `CoreRecordPattern { fields }` | None (structural) | Destructure named fields |
| `CoreTuplePattern { elements }` | None (structural) | Destructure array indices |

### 6.2 Nested Patterns

Compile recursively. For deeply nested patterns, generate nested conditionals:
```vibefun
match x { | Some({ name: "Alice", age }) => age | _ => 0 }
```
```javascript
if (x.$tag === "Some" && x.$0.name === "Alice") {
    const age = x.$0.age;
    return age;
}
return 0;
```

### 6.3 Guard Expressions

Guards are evaluated after pattern matching but before executing the body:
```javascript
if (/* pattern matches */) {
    const bindings = /* extract bindings */;
    if (guard) {
        return body;
    }
}
// Continue to next case
```

---

## 7. Declaration Compilation Rules

### 7.1 Let Declarations (CoreLetDecl)

**Non-exported:**
```javascript
const name = value;
```

**Exported:**
```javascript
const name = value;
// At end of file:
export { name };
```

### 7.2 Recursive Let Groups (CoreLetRecGroup)

```javascript
const f = (x) => g(x);
const g = (x) => f(x);
// Exports at end if needed
```

### 7.3 Type Declarations (CoreTypeDecl)

**Variant types:** Generate constructor functions:
```vibefun
type Option<T> = Some(T) | None;
```
```javascript
const Some = ($0) => ({ $tag: "Some", $0 });
const None = { $tag: "None" };
```

**Record types:** No runtime code (structural typing).

**Type aliases:** No runtime code (erased).

### 7.4 External Declarations (CoreExternalDecl)

**Without module:**
```vibefun
external console_log: (String) -> Unit = "console.log";
```
```javascript
const console_log = console.log;
```

**With module import:**
```vibefun
external fetch: (String) -> Promise<Response> = "fetch" from "node-fetch";
```
```javascript
import { fetch as $ext_fetch } from "node-fetch";
const fetch = $ext_fetch;
```

**Binding to global:**
```vibefun
external parseInt: (String) -> Int = "parseInt";
```
```javascript
const $parseInt = parseInt;  // Global reference
```

### 7.5 External Type Declarations (CoreExternalTypeDecl)

No runtime code generated (types are erased).

### 7.6 Import Declarations (CoreImportDecl)

```vibefun
import { foo, bar as baz } from './module';
```
```javascript
import { foo, bar as baz } from "./module.js";
```

**Type-only imports:** No runtime code.

**Extension handling:** Append `.js` to relative imports.

---

## 8. Identifier Handling

### 8.1 JavaScript Reserved Words

The following identifiers must be escaped if used as variable names:
- Keywords: `break`, `case`, `catch`, `class`, `const`, `continue`, `debugger`, `default`, `delete`, `do`, `else`, `enum`, `export`, `extends`, `false`, `finally`, `for`, `function`, `if`, `import`, `in`, `instanceof`, `new`, `null`, `return`, `super`, `switch`, `this`, `throw`, `true`, `try`, `typeof`, `var`, `void`, `while`, `with`, `yield`
- Strict mode reserved: `implements`, `interface`, `let`, `package`, `private`, `protected`, `public`, `static`
- Future reserved: `await`

### 8.2 Escaping Strategy

Append `$` suffix to reserved words:
```
class -> class$
function -> function$
```

### 8.3 Compiler-Generated Names

Use `$` prefix for compiler-generated identifiers:
- `$match` - Match expression scrutinee
- `$0`, `$1`, ... - Variant constructor arguments
- `$tag` - Variant tag property
- `$value` - Ref value property
- `$ext_*` - External import bindings

### 8.4 Valid JavaScript Identifiers

Vibefun identifiers that are valid in JavaScript pass through unchanged. Unicode identifiers are preserved if valid in ES2020.

---

## 9. Equality Semantics

### 9.1 Primitive Equality

Use `===` for primitives (Int, Float, String, Bool):
```javascript
a === b
```

### 9.2 Structural Equality for Records and Variants

For composite types, `==` should compare structurally. Options:
1. **Simple:** Generate deep comparison code inline
2. **Runtime helper:** Call `$equals(a, b)` function
3. **Inline for simple cases:** Use `===` when types are known primitive

**Recommendation:** Start with `===` for MVP (works for primitives and reference equality). Add structural equality as needed.

---

## 10. Error Handling

### 10.1 Code Generator Errors

The code generator should throw for:
- **Unknown AST node kind:** Internal compiler error
- **Missing required field:** Internal compiler error
- **Invalid Core AST structure:** Internal compiler error

These indicate bugs in earlier phases, not user errors.

### 10.2 Runtime Errors

Generate code that throws for:
- **panic(message):** `throw new Error(message)`
- **Integer division by zero:** `if (b === 0) throw new Error("Division by zero")`

**Non-exhaustive match:** Should never occur (typechecker ensures exhaustiveness), but generate fallback throw as safety net:
```javascript
throw new Error("Non-exhaustive match");
```

---

## 11. Module Architecture

### 11.1 Recommended File Structure

```
packages/core/src/codegen/
├── index.ts              # Public API (generate function)
├── generator.ts          # Main CodeGenerator class
├── emit/
│   ├── expression.ts     # Expression emission
│   ├── pattern.ts        # Pattern emission
│   ├── declaration.ts    # Declaration emission
│   └── operator.ts       # Operator emission
├── identifier.ts         # Identifier handling/escaping
├── output.ts             # Output buffer management
└── generator.test.ts     # Unit tests
```

### 11.2 Generator Class Design

```typescript
class CodeGenerator {
    private output: OutputBuffer;
    private indent: number;

    generate(module: TypedModule): GenerateResult;
    private emitDeclaration(decl: CoreDeclaration): void;
    private emitExpr(expr: CoreExpr): string;
    private emitPattern(pattern: CorePattern): string;
}
```

### 11.3 Extensibility Points

For future target support:
- Abstract `Emitter` interface
- Target-specific emitter implementations
- Shared identifier handling

---

## 12. Future Extensibility

### 12.1 Multiple Targets

Prepare for:
- `es2020` - Current baseline
- `es2022` - Top-level await, class fields
- `esnext` - Latest ECMAScript features

**Approach:** Use strategy pattern for target-specific code generation.

### 12.2 Source Maps

Requirements for future implementation:
- Track source locations through generation
- Build source map as code is emitted
- Output inline or external source map
- Map generated JS lines/columns to `.vf` source

**Preparation:** Preserve `loc` information, emit code with location tracking.

### 12.3 Runtime Type Checking

Three modes:
- `none` - No runtime checks (production)
- `ffi` - Check values crossing FFI boundary
- `all` - Check all operations (development)

**Preparation:** Identify FFI boundaries (external calls, unsafe blocks).

---

## 13. Testing Strategy

### 13.1 Unit Tests

- Test each expression type compilation
- Test each pattern type compilation
- Test each declaration type compilation
- Test identifier escaping
- Test operator precedence

### 13.2 Integration Tests

- End-to-end compilation of `.vf` programs
- Verify generated JS is syntactically valid (parse with Node)
- Verify generated JS executes correctly

### 13.3 Snapshot Tests

- Golden file tests for representative programs
- Compare generated output against expected

### 13.4 Semantic Tests

- Verify currying behavior
- Verify pattern matching semantics
- Verify short-circuit evaluation
- Verify mutable reference behavior

---

## 14. Acceptance Criteria

### 14.1 MVP Functional Requirements

1. All Core AST expression types compile correctly
2. All Core AST pattern types compile correctly
3. All Core AST declaration types compile correctly
4. Generated code is valid ES2020
5. Generated code executes correctly
6. Currying works (partial application)
7. Pattern matching with guards works
8. Short-circuit evaluation preserved
9. Mutable references work
10. External declarations work

### 14.2 MVP Non-Functional Requirements

1. Generated code is human-readable
2. No memory leaks in generated code
3. Reasonable code size (no excessive bloat)
4. Compiles in reasonable time

### 14.3 Integration Requirements

1. Integrates with existing CLI via `generate()` function
2. Accepts `TypedModule` from typechecker
3. Returns `GenerateResult` with `code` string
4. Handles `filename` option for comments

---

## 15. Critical Reference Files

| File | Purpose |
|------|---------|
| `packages/core/src/types/core-ast.ts` | Core AST node definitions |
| `packages/core/src/typechecker/typechecker.ts` | TypedModule interface |
| `packages/core/src/types/environment.ts` | TypeEnv structure |
| `packages/core/src/codegen/index.ts` | Current stub implementation |
| `packages/cli/src/commands/compile.ts` | CLI integration point |
| `docs/spec/12-compilation/codegen.md` | Language spec for codegen |

---

## Appendix A: Complete Core AST Node Reference

### Expressions (CoreExpr)
- `CoreIntLit`, `CoreFloatLit`, `CoreStringLit`, `CoreBoolLit`, `CoreUnitLit`
- `CoreVar`, `CoreLet`, `CoreLetRecExpr`
- `CoreLambda`, `CoreApp`
- `CoreMatch`
- `CoreRecord`, `CoreRecordAccess`, `CoreRecordUpdate`
- `CoreVariant`
- `CoreBinOp`, `CoreUnaryOp`
- `CoreTypeAnnotation`, `CoreUnsafe`
- `CoreTuple`

### Patterns (CorePattern)
- `CoreWildcardPattern`, `CoreVarPattern`
- `CoreLiteralPattern`
- `CoreVariantPattern`, `CoreRecordPattern`, `CoreTuplePattern`

### Declarations (CoreDeclaration)
- `CoreLetDecl`, `CoreLetRecGroup`
- `CoreTypeDecl`
- `CoreExternalDecl`, `CoreExternalTypeDecl`
- `CoreImportDecl`
