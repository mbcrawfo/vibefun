# Vibefun Code Generator Requirements

## 1. Overview

This document specifies the requirements for the vibefun code generator, which transforms a `TypedModule` (the output of the type checker) into executable JavaScript.

### 1.1 Purpose

The code generator is the final phase of the compilation pipeline:

```
Source → Lexer → Parser → Desugarer → TypeChecker → Optimizer → CodeGen → JavaScript
```

It produces readable, ES2020-compliant JavaScript that correctly implements vibefun semantics.

### 1.2 Design Goals

1. **Correctness**: Generated code must faithfully implement vibefun semantics
2. **Readability**: Output should be human-readable for debugging
3. **Modularity**: Architecture must support multiple output targets in the future
4. **Performance**: Generated code should be reasonably efficient

### 1.3 Non-Goals (MVP)

The following are explicitly out of scope for the initial implementation:

1. **Source maps**: Will be added in a future phase
2. **Runtime type checking**: FFI boundary checks deferred
3. **Multiple ES targets**: Only ES2020 for now
4. **Minification**: Output prioritizes readability
5. **Tree shaking**: Emit all declarations

---

## 2. Input/Output Contract

### 2.1 Input: TypedModule

```typescript
interface TypedModule {
    module: CoreModule;                    // Desugared AST
    env: TypeEnv;                          // Type environment
    declarationTypes: Map<string, Type>;   // Inferred types for declarations
}
```

**CoreModule structure:**
- `imports: CoreImportDecl[]` - Import declarations
- `declarations: CoreDeclaration[]` - Top-level declarations
- `loc: Location` - Source location

**TypeEnv provides:**
- Value bindings (including external declarations with `jsName` and `from` properties)
- Type bindings (for variant constructor information)

### 2.2 Output: GenerateResult

```typescript
interface GenerateResult {
    readonly code: string;     // Generated JavaScript
    // Future: readonly sourceMap?: SourceMap;
}
```

### 2.3 Current Interface

```typescript
interface GenerateOptions {
    readonly filename?: string;  // For output comments
    // Future extensions:
    // readonly target?: "es2020" | "es2022" | "esnext";
    // readonly sourceMap?: boolean;
    // readonly runtimeChecks?: "ffi" | "all" | "none";
}

function generate(typedModule: TypedModule, options?: GenerateOptions): GenerateResult
```

---

## 3. JavaScript Target Specification

### 3.1 ES2020 Baseline (Initial Implementation)

The initial implementation targets ES2020. Generated code may use:
- `const` and `let` declarations
- Arrow functions
- Destructuring assignment and parameters
- Spread operator (`...`)
- Template literals
- `===` strict equality
- ES6 modules (`import`/`export`)

### 3.2 Output Format

- **Module format**: ES6 modules (not CommonJS)
- **File extension**: Output files should be `.js`
- **Exports**: Collected at end of file for clarity
- **Imports**: At top of file, after header comment

### 3.3 Header Comment

Generated files should include a header:
```javascript
// Generated by Vibefun compiler
// Source: <filename>
```

---

## 4. Runtime Value Representations

### 4.1 Primitive Types

| Vibefun Type | JavaScript Representation |
|--------------|--------------------------|
| `Int` | `number` (safe integer range) |
| `Float` | `number` (IEEE 754 double) |
| `String` | `string` (UTF-16) |
| `Bool` | `boolean` |
| `Unit` | `undefined` |

### 4.2 Records

**Representation:** Plain JavaScript objects

```vibefun
let person = { name: "Alice", age: 30 };
```
```javascript
const person = { name: "Alice", age: 30 };
```

**Field access:**
```vibefun
person.name
```
```javascript
person.name
```

**Record update (spread):**
```vibefun
{ ...person, age: 31 }
```
```javascript
{ ...person, age: 31 }
```

### 4.3 Variants (Algebraic Data Types)

**Representation:** Tagged objects with `$tag` property

| Constructor | JavaScript |
|-------------|------------|
| No args: `None` | `{ $tag: "None" }` |
| Single arg: `Some(x)` | `{ $tag: "Some", $0: x }` |
| Multiple args: `Cons(h, t)` | `{ $tag: "Cons", $0: h, $1: t }` |

**Rationale for `$tag`:** Using `$` prefix avoids collision with user field names while remaining valid JS.

**Constructor functions:**
```javascript
const Some = ($0) => ({ $tag: "Some", $0 });
const None = { $tag: "None" };
const Cons = ($0) => ($1) => ({ $tag: "Cons", $0, $1 });
const Nil = { $tag: "Nil" };
```

### 4.4 Lists

Lists use the Cons/Nil variant representation:
```javascript
// [1, 2, 3] compiles to:
Cons(1)(Cons(2)(Cons(3)(Nil)))
```

### 4.5 Tuples

**Representation:** JavaScript arrays

```vibefun
let triple = (1, "hello", true);
```
```javascript
const triple = [1, "hello", true];
```

### 4.6 Mutable References (Ref<T>)

**Representation:** Objects with `$value` property

In vibefun, mutable references are created with `let mut x = ref(value)` syntax. The `ref(...)` call creates a mutable cell.

```vibefun
let mut counter = ref(0);  // Create mutable reference
let value = !counter;      // Dereference (read)
counter := 5;              // Assign (write)
```
```javascript
const counter = ref(0);
const value = counter.$value;
counter.$value = 5;
```

**Implementation:** The runtime preamble includes a `ref` helper function:
```javascript
const ref = ($value) => ({ $value });
```

At the Core AST level, `ref(0)` appears as a `CoreApp` calling a `ref` function with argument `0`. The code generator emits this as a normal function call `ref(0)`, relying on the runtime helper.

### 4.7 Functions

All functions are curried (single parameter):

```vibefun
let add = (x, y) => x + y;
```
```javascript
const add = (x) => (y) => x + y;
```

**Note:** The desugarer already converts multi-param lambdas to nested single-param lambdas, so `CoreLambda` always has exactly one parameter.

---

## 4A. Desugared Constructs (Not in Core AST)

The following surface syntax constructs are **desugared before** reaching the code generator. The code generator never sees them:

| Surface Syntax | Desugared To | Notes |
|----------------|--------------|-------|
| `if c then a else b` | `match c { \| true => a \| false => b }` | Match on boolean |
| `if c then a` | `match c { \| true => a \| false => () }` | Unit else branch |
| `while cond { body }` | Recursive function | See desugaring spec |
| `[1, 2, 3]` | `Cons(1)(Cons(2)(Cons(3)(Nil)))` | List literals |
| `x \|> f` | `f(x)` | Pipe operator |
| `f >> g` | `(x) => g(f(x))` | Forward composition |
| `(a, b) => body` | `(a) => (b) => body` | Multi-param lambda |
| `{ stmt1; stmt2; expr }` | Nested let bindings | Block expressions |
| `p1 \| p2 => body` | Two match cases | Or-patterns |

**Implication:** The code generator only handles Core AST nodes. If you see a construct in vibefun source that isn't in Core AST, it was desugared before reaching codegen.

---

## 5. Expression Compilation Rules

### 5.1 Literals

| Core AST | JavaScript |
|----------|------------|
| `CoreIntLit { value: 42 }` | `42` |
| `CoreIntLit { value: -5 }` | `(-5)` |
| `CoreFloatLit { value: 3.14 }` | `3.14` |
| `CoreFloatLit { value: Infinity }` | `Infinity` |
| `CoreFloatLit { value: -Infinity }` | `(-Infinity)` |
| `CoreFloatLit { value: NaN }` | `NaN` |
| `CoreStringLit { value: "hi" }` | `"hi"` |
| `CoreBoolLit { value: true }` | `true` |
| `CoreUnitLit` | `undefined` |

**Negative numbers:** Wrap negative literals in parentheses to avoid ambiguity with subtraction: `(-5)`.

**Float special values:** JavaScript's `Infinity`, `-Infinity`, and `NaN` are valid identifiers. Emit them directly. Note: `NaN !== NaN` in JavaScript (IEEE 754 semantics).

**String escaping:** The following characters must be escaped:
- `\` → `\\`
- `"` → `\"`
- `\n` → `\\n`
- `\r` → `\\r`
- `\t` → `\\t`
- `\0` → `\\0`
- Control characters (0x00-0x1F) → `\\uXXXX`
- Line separators (U+2028, U+2029) → `\\uXXXX`

Use JSON.stringify() as a reference implementation for string escaping.

### 5.2 Variables

| Core AST | JavaScript |
|----------|------------|
| `CoreVar { name: "x" }` | `x` (or escaped if reserved) |

### 5.3 Let Bindings (CoreLet)

`CoreLet` represents a let-in expression: `let pattern = value in body`.

**Key decision:** How to emit depends on context:

**Expression context (nested inside another expression):**
```javascript
// CoreLet { pattern: CoreVarPattern("x"), value, body }
// Use IIFE to create scope
(() => {
    const x = value;
    return body;
})()
```

**Statement context (at top level of a block/function):**
```javascript
// Can emit directly as statements
const x = value;
// ... body follows as subsequent statements
```

**Pattern destructuring:**
```javascript
// CoreLet { pattern: CoreRecordPattern(...), ... }
const { name, age } = person;

// CoreLet { pattern: CoreTuplePattern(...), ... }
const [first, second] = tuple;
```

**Recursive bindings (CoreLet with `recursive: true`):**
```javascript
// let rec factorial = (n) => ... in body
const factorial = (n) => n <= 1 ? 1 : n * factorial(n - 1);
// body follows
```

**Mutable bindings (CoreLet with `mutable: true`):**

The value is already a ref object. Just emit as const:
```javascript
// let mut x = ref(0) in body
const x = { $value: 0 };
// or: const x = ref(0);
```

### 5.4 Recursive Bindings (CoreLet with recursive: true)

For self-recursive functions:
```javascript
const factorial = (n) => n <= 1 ? 1 : n * factorial(n - 1);
```

### 5.5 Mutually Recursive Bindings (CoreLetRecExpr)

```javascript
const isEven = (n) => n === 0 ? true : isOdd(n - 1);
const isOdd = (n) => n === 0 ? false : isEven(n - 1);
```

**Note:** JavaScript hoisting handles forward references to functions.

### 5.6 Lambdas (CoreLambda)

```javascript
(param) => body
```

**Pattern parameters:** Destructure in parameter position:
```javascript
({ name, age }) => name
([head, ...tail]) => head
```

### 5.7 Function Application (CoreApp)

**Note:** `CoreApp` has an `args: CoreExpr[]` field that may contain multiple arguments.

**Single argument (args.length === 1):**
```javascript
func(arg)
```

**Multiple arguments (args.length > 1):**
Generate curried calls:
```javascript
// CoreApp { func, args: [arg1, arg2, arg3] }
func(arg1)(arg2)(arg3)
```

**Optimization opportunity:** When the callee is known to be a multi-argument function, a single call `func(arg1, arg2, arg3)` may be more efficient. This is optional for MVP.

**Nested application:**
When `func` is itself a `CoreApp`, emit the outer application:
```javascript
// CoreApp { func: CoreApp { func: f, args: [a] }, args: [b] }
f(a)(b)
```

### 5.8 Match Expressions (CoreMatch)

Pattern matching compiles to conditional chains. The generated code must:
- Evaluate the scrutinee exactly once
- Test patterns top-to-bottom (first match wins)
- Evaluate guards after pattern match, before body
- Bind pattern variables in scope for guard and body

**Example compilation:**
```vibefun
match value {
    | 0 => "zero"
    | n when n > 0 => "positive"
    | _ => "negative"
}
```
```javascript
(($match) => {
    if ($match === 0) return "zero";
    { const n = $match; if (n > 0) return "positive"; }
    return "negative";
})(value)
```

**Variant matching:**
```vibefun
match opt {
    | Some(x) => x
    | None => 0
}
```
```javascript
(($match) => {
    if ($match.$tag === "Some") { const x = $match.$0; return x; }
    if ($match.$tag === "None") return 0;
})($opt)
```

### 5.9 Records

**Construction:**
```javascript
{ field1: value1, field2: value2 }
```

**Field access:**
```javascript
record.field
```

**Update (CoreRecordUpdate):**
```javascript
{ ...record, field: newValue }
```

**Spread fields:** Preserve spread in output:
```javascript
{ ...base, extra: value }
```

### 5.10 Variants (CoreVariant)

Use constructor functions or object literals:
```javascript
// Some(42)
{ $tag: "Some", $0: 42 }
// Or if constructor function exists:
Some(42)
```

### 5.11 Binary Operators (CoreBinOp)

| Core Op | JavaScript | Notes |
|---------|------------|-------|
| `Add` | `a + b` | Works for both Int and Float |
| `Subtract` | `a - b` | |
| `Multiply` | `a * b` | |
| `IntDivide` | `Math.trunc(a / b)` | Integer division (truncates toward zero) |
| `FloatDivide` | `a / b` | Float division |
| `Modulo` | `a % b` | |
| `Equal` | `$eq(a, b)` or `a === b` | See Section 9 |
| `NotEqual` | `!$eq(a, b)` or `a !== b` | See Section 9 |
| `LessThan` | `a < b` | Primitives only |
| `LessEqual` | `a <= b` | Primitives only |
| `GreaterThan` | `a > b` | Primitives only |
| `GreaterEqual` | `a >= b` | Primitives only |
| `LogicalAnd` | `a && b` | Short-circuit preserved |
| `LogicalOr` | `a \|\| b` | Short-circuit preserved |
| `Concat` | `a + b` | String concatenation |
| `RefAssign` | `(a.$value = b, undefined)` | Returns Unit |

**Division operators:**

The Core AST uses separate operators for integer and float division:
- `IntDivide`: Emits `Math.trunc(a / b)` - truncates toward zero
- `FloatDivide`: Emits `a / b` - standard IEEE 754 division

The desugarer/typechecker emits the appropriate operator based on operand types. This allows codegen to emit the correct JavaScript without needing type information.

**RefAssign return value:**

The `:=` operator returns `Unit`. JavaScript assignment returns the assigned value, so wrap in comma expression:
```javascript
(a.$value = b, undefined)
```

Or if result is discarded (statement context), just emit:
```javascript
a.$value = b;
```

**Short-circuit operators:**

`&&` and `||` must preserve short-circuit semantics. The generated code must not evaluate the right operand if the left determines the result:
```javascript
// a && b
// If a is falsy, b is never evaluated
a && b

// a || b
// If a is truthy, b is never evaluated
a || b
```

**Comparison operators:**

`<`, `<=`, `>`, `>=` are only defined for primitives (Int, Float, String). Do not generate comparison for records/variants.

### 5.12 Unary Operators (CoreUnaryOp)

| Core Op | JavaScript |
|---------|------------|
| `Negate` | `-expr` |
| `LogicalNot` | `!expr` |
| `Deref` | `expr.$value` |

### 5.13 Tuples (CoreTuple)

```javascript
[element0, element1, element2]
```

### 5.14 Type Annotations (CoreTypeAnnotation)

Compile the inner expression only (annotations are erased at runtime):
```javascript
// (expr : Type) compiles to just:
expr
```

### 5.15 Unsafe Blocks (CoreUnsafe)

Compile the inner expression (the unsafe marker is erased):
```javascript
// unsafe { expr } compiles to:
expr
```

---

## 5A. Operator Precedence and Parenthesization

### 5A.1 The Problem

When emitting nested binary operations, parentheses may be needed to preserve semantics:
```vibefun
// Source: a * (b + c)
// Wrong: a * b + c   (different semantics)
// Right: a * (b + c)
```

### 5A.2 JavaScript Precedence Reference

From highest to lowest (relevant subset):
1. Member access (`.`), function call (`()`)
2. Unary (`!`, `-`)
3. Multiplicative (`*`, `/`, `%`)
4. Additive (`+`, `-`)
5. Comparison (`<`, `<=`, `>`, `>=`)
6. Equality (`===`, `!==`)
7. Logical AND (`&&`)
8. Logical OR (`||`)
9. Assignment (`=`)

### 5A.3 Parenthesization Strategy

**Option A (Conservative):** Always parenthesize binary operations
```javascript
((a) * ((b) + (c)))  // Safe but verbose
```

**Option B (Minimal):** Only parenthesize when precedence requires
```javascript
a * (b + c)  // Minimal necessary parens
```

**Option C (Hybrid - Recommended):** Parenthesize based on context
- Parenthesize when child precedence < parent precedence
- Parenthesize when child is same precedence and associativity matters
- Never parenthesize literals, variables, or function calls

**Implementation:**
```typescript
function needsParens(parent: CoreBinaryOp, child: CoreExpr, position: "left" | "right"): boolean {
    if (child.kind !== "CoreBinOp") return false;
    const parentPrec = precedence(parent);
    const childPrec = precedence(child.op);
    if (childPrec < parentPrec) return true;
    if (childPrec === parentPrec && position === "right") return true; // Handle right-associativity
    return false;
}
```

### 5A.4 Unary Operator Parenthesization

Unary operators need parentheses in certain contexts:
```javascript
// CoreUnaryOp { op: "Negate", expr: CoreBinOp { ... } }
-(a + b)  // Parentheses needed

// CoreUnaryOp { op: "LogicalNot", expr: CoreVar { name: "x" } }
!x  // No parentheses needed

// CoreUnaryOp nested in CoreBinOp
a + -b  // Works without parens in JS, but (-b) is clearer
```

**Recommendation:** Parenthesize unary operands that are binary operations.

### 5A.5 Function Application Parenthesization

When the callee is an expression (not a simple variable):
```javascript
// CoreApp { func: CoreLambda { ... }, args: [x] }
((param) => body)(x)  // Parentheses around lambda

// CoreApp { func: CoreMatch { ... }, args: [x] }
(matchExpr)(x)  // Parentheses around match
```

**Rule:** Parenthesize `func` if it's not a `CoreVar` or `CoreRecordAccess`.

---

## 5B. Expression vs Statement Context

### 5B.1 Context Types

Expressions are emitted differently depending on their syntactic context:

1. **Statement context**: At top level of a block or module body
2. **Expression context**: Inside another expression

### 5B.2 CoreLet in Different Contexts

**Statement context (top-level binding):**
```javascript
const x = expr;
// ... body follows as subsequent statements
```

**Expression context (nested in another expression):**
```javascript
// Option A: IIFE
(() => { const x = expr; return body; })()

// Option B: Comma operator (simpler cases)
(x = expr, body)  // Only if x can be a simple assignment
```

**Recommendation:** Use IIFEs for nested let expressions. They're clearer and handle all cases.

### 5B.3 CoreMatch in Statement vs Expression Context

**Statement context:**
```javascript
// Can use if statements
if ($match.$tag === "Some") {
    const x = $match.$0;
    return body1;
}
// ... more cases
```

**Expression context:**
```javascript
// Must use IIFE
(($match) => {
    if ($match.$tag === "Some") { const x = $match.$0; return body1; }
    // ... more cases
})(scrutinee)
```

### 5B.4 Semicolons and Statement Termination

**Rules:**
- Declarations at module top level end with semicolons
- Statements inside IIFEs end with semicolons
- Expression-only returns don't need semicolons before `}`
- Use consistent style (recommend semicolons everywhere)

**Example:**
```javascript
const add = (x) => (y) => x + y;  // Semicolon after declaration
const result = (() => {
    const temp = compute();  // Semicolon
    return temp + 1;  // Semicolon optional before }
})();
```

---

## 6. Pattern Compilation Rules

### 6.1 Pattern Types

| Pattern | Test | Binding |
|---------|------|---------|
| `CoreWildcardPattern` | None (always matches) | None |
| `CoreVarPattern { name }` | None (always matches) | `const name = value;` |
| `CoreLiteralPattern { literal: n }` | `value === n` | None |
| `CoreVariantPattern { constructor, args }` | `value.$tag === "Ctor"` | Destructure `$0`, `$1`, etc. |
| `CoreRecordPattern { fields }` | None (structural) | Destructure named fields |
| `CoreTuplePattern { elements }` | None (structural) | Destructure array indices |

**CoreLiteral type:**
The `CoreLiteralPattern.literal` field has type `number | string | boolean | null`:
- `number`: Match integer or float literals (`value === 42`)
- `string`: Match string literals (`value === "hello"`)
- `boolean`: Match `true` or `false` (`value === true`)
- `null`: Match the `null` value (`value === null`)

**Note:** The `null` literal is primarily used for JavaScript interop. In pure vibefun code, `None` (a variant) is used instead.

### 6.2 Nested Patterns

Compile recursively. For deeply nested patterns, generate nested conditionals:
```vibefun
match x { | Some({ name: "Alice", age }) => age | _ => 0 }
```
```javascript
if (x.$tag === "Some" && x.$0.name === "Alice") {
    const age = x.$0.age;
    return age;
}
return 0;
```

### 6.3 Guard Expressions

Guards are evaluated after pattern matching but before executing the body:
```javascript
if (/* pattern matches */) {
    const bindings = /* extract bindings */;
    if (guard) {
        return body;
    }
}
// Continue to next case
```

---

## 7. Declaration Compilation Rules

### 7.1 Let Declarations (CoreLetDecl)

**Simple variable pattern (CoreVarPattern):**

Non-exported:
```javascript
const name = value;
```

Exported:
```javascript
const name = value;
// At end of file:
export { name };
```

**Pattern destructuring:**

When `pattern` is not a simple variable (e.g., tuple or record pattern), destructure:

```javascript
// CoreLetDecl { pattern: CoreTuplePattern { elements: [a, b] }, value, exported: false }
const [a, b] = value;

// CoreLetDecl { pattern: CoreRecordPattern { fields: [{name: "x", ...}, {name: "y", ...}] }, ... }
const { x, y } = value;
```

**Exported pattern destructuring:**

When a destructuring pattern is exported, export all bound names:

```javascript
const { x, y } = value;
// At end of file:
export { x, y };
```

**Mutable declarations:**

When `mutable: true`, the binding is a `Ref<T>`. The value is already a ref object, so just use `const`:

```javascript
// let mut counter = ref(0)
const counter = { $value: 0 };  // Or: const counter = ref(0);
```

Note: Even mutable refs use `const` because the binding itself isn't reassigned—only the ref's `$value` is mutated.

### 7.2 Recursive Let Groups (CoreLetRecGroup)

```javascript
const f = (x) => g(x);
const g = (x) => f(x);
// Exports at end if needed
```

### 7.3 Type Declarations (CoreTypeDecl)

**Variant types:** Generate constructor functions:
```vibefun
type Option<T> = Some(T) | None;
```
```javascript
const Some = ($0) => ({ $tag: "Some", $0 });
const None = { $tag: "None" };
```

**Record types:** No runtime code (structural typing).

**Type aliases:** No runtime code (erased).

### 7.4 External Declarations (CoreExternalDecl)

**Without module:**
```vibefun
external console_log: (String) -> Unit = "console.log";
```
```javascript
const console_log = console.log;
```

**With module import:**
```vibefun
external fetch: (String) -> Promise<Response> = "fetch" from "node-fetch";
```
```javascript
import { fetch as $ext_fetch } from "node-fetch";
const fetch = $ext_fetch;
```

**Binding to global:**
```vibefun
external parseInt: (String) -> Int = "parseInt";
```
```javascript
const $parseInt = parseInt;  // Global reference
```

### 7.5 External Type Declarations (CoreExternalTypeDecl)

No runtime code generated (types are erased).

### 7.6 Import Declarations (CoreImportDecl)

```vibefun
import { foo, bar as baz } from './module';
```
```javascript
import { foo, bar as baz } from "./module.js";
```

**Type-only imports:** Filter out items where `isType === true`. If all items are type-only, emit no import.

**Extension handling rules:**
1. **Relative paths** (start with `./` or `../`): Append `.js` extension
   - `'./module'` → `"./module.js"`
   - `'../utils/helper'` → `"../utils/helper.js"`
2. **Package imports** (no path prefix): Pass through unchanged
   - `'lodash'` → `"lodash"`
   - `'@scope/package'` → `"@scope/package"`
3. **Absolute paths** (start with `/`): Append `.js` extension
   - `'/lib/utils'` → `"/lib/utils.js"`

**Example with mixed type/value imports:**
```typescript
// CoreImportDecl {
//   items: [
//     { name: "foo", isType: false },
//     { name: "MyType", isType: true },
//     { name: "bar", alias: "baz", isType: false }
//   ],
//   from: "./module"
// }
```
```javascript
import { foo, bar as baz } from "./module.js";
// MyType is omitted (type-only)
```

---

## 8. Identifier Handling

### 8.1 JavaScript Reserved Words

The following identifiers must be escaped if used as variable names:
- Keywords: `break`, `case`, `catch`, `class`, `const`, `continue`, `debugger`, `default`, `delete`, `do`, `else`, `enum`, `export`, `extends`, `false`, `finally`, `for`, `function`, `if`, `import`, `in`, `instanceof`, `new`, `null`, `return`, `super`, `switch`, `this`, `throw`, `true`, `try`, `typeof`, `var`, `void`, `while`, `with`, `yield`
- Strict mode reserved: `implements`, `interface`, `let`, `package`, `private`, `protected`, `public`, `static`
- Future reserved: `await`

### 8.2 Escaping Strategy

Append `$` suffix to reserved words:
```
class -> class$
function -> function$
```

### 8.3 Compiler-Generated Names

Use `$` prefix for compiler-generated identifiers:
- `$match` - Match expression scrutinee
- `$0`, `$1`, ... - Variant constructor arguments
- `$tag` - Variant tag property
- `$value` - Ref value property
- `$ext_*` - External import bindings

### 8.4 Valid JavaScript Identifiers

Vibefun identifiers that are valid in JavaScript pass through unchanged. Unicode identifiers are preserved if valid in ES2020.

---

## 9. Equality Semantics

### 9.1 Primitive Equality

Use `===` for primitives (Int, Float, String, Bool):
```javascript
a === b
```

This works correctly because JavaScript's `===` handles these types appropriately.

**NaN handling:** `NaN == NaN` returns `false`, following JavaScript/IEEE 754 semantics. This means two NaN values are never equal, which is consistent with JavaScript's behavior.

### 9.2 Structural Equality for Records and Variants

Vibefun's `==` operator provides **structural equality** for composite types. This is a key semantic difference from JavaScript's reference equality.

**Problem:** JavaScript's `===` compares objects by reference:
```javascript
{ a: 1 } === { a: 1 }  // false (different objects)
[1, 2] === [1, 2]      // false (different arrays)
```

**Implementation:** Use `$eq` runtime helper that:
- Returns `a === b` for primitives (including NaN's IEEE 754 behavior)
- Compares `$tag` for variants, then compares fields recursively
- Compares all fields for records
- Compares element-wise for tuples/arrays
- Uses `===` for refs (identity equality, not structural equality of contents)
- Functions are not comparable (filtered at type-check time)

The `$eq` helper is provided by the runtime preamble (see Section 11.5A).

### 9.3 Inequality (NotEqual)

Generate the negation of equality:
```javascript
!$eq(a, b)
// Or for primitives:
a !== b
```

---

## 10. Error Handling

### 10.1 Code Generator Errors

The code generator should throw for:
- **Unknown AST node kind:** Internal compiler error
- **Missing required field:** Internal compiler error
- **Invalid Core AST structure:** Internal compiler error

These indicate bugs in earlier phases, not user errors.

### 10.2 Runtime Errors

Generate code that throws for:
- **panic(message):** `throw new Error(message)`

**Integer division by zero:** Follows JavaScript behavior - returns `Infinity`, `-Infinity`, or `NaN` depending on operands. No runtime exception is thrown. Users who need explicit error handling should check for zero before dividing.

**Non-exhaustive match:** Should never occur (typechecker ensures exhaustiveness), but generate fallback throw as safety net:
```javascript
throw new Error("Non-exhaustive match");
```

---

## 11. Module Architecture

### 11.1 Recommended File Structure

```
packages/core/src/codegen/
├── index.ts              # Public API (generate function)
├── generator.ts          # Main CodeGenerator class
├── emit/
│   ├── expression.ts     # Expression emission
│   ├── pattern.ts        # Pattern emission
│   ├── declaration.ts    # Declaration emission
│   └── operator.ts       # Operator emission
├── identifier.ts         # Identifier handling/escaping
├── output.ts             # Output buffer management
└── generator.test.ts     # Unit tests
```

### 11.2 Generator Class Design

```typescript
class CodeGenerator {
    private output: OutputBuffer;
    private indent: number;

    generate(module: TypedModule): GenerateResult;
    private emitDeclaration(decl: CoreDeclaration): void;
    private emitExpr(expr: CoreExpr): string;
    private emitPattern(pattern: CorePattern): string;
}
```

### 11.3 Extensibility Points

For future target support:
- Abstract `Emitter` interface
- Target-specific emitter implementations
- Shared identifier handling

### 11.4 Output Buffer Management

**OutputBuffer class responsibilities:**
- Maintain generated code string
- Track current indentation level
- Handle newlines and semicolons consistently
- Collect exports for end-of-file emission

**Interface sketch:**
```typescript
class OutputBuffer {
    private parts: string[] = [];
    private indentLevel: number = 0;
    private exports: string[] = [];

    emit(code: string): void;
    emitLine(code: string): void;  // Adds newline
    indent(): void;
    dedent(): void;
    addExport(name: string): void;
    finish(): string;  // Joins parts + exports
}
```

### 11.5 Output Formatting Rules

**Indentation:**
- Use 2 spaces per indent level (configurable)
- Indent inside: IIFEs, match bodies, arrow function bodies (when multi-line)

**Newlines:**
- One newline between top-level declarations
- No trailing newlines inside expressions
- One newline at end of file

**Semicolons:**
- Always emit semicolons after statements
- Follow consistent style (no ASI reliance)

**Line length:**
- No strict limit for MVP
- Future: Optional line wrapping

### 11.6 Runtime Preamble

The code generator emits a runtime preamble containing helper functions used by generated code:

```javascript
// Runtime helpers
const ref = ($value) => ({ $value });

const $eq = (a, b) => {
    if (a === b) return true;
    if (a == null || b == null) return false;
    if (typeof a !== "object") return false;

    // Variant comparison
    if ("$tag" in a) {
        if (a.$tag !== b.$tag) return false;
        // Compare all $N fields
        for (let i = 0; `$${i}` in a; i++) {
            if (!$eq(a[`$${i}`], b[`$${i}`])) return false;
        }
        return true;
    }

    // Tuple comparison (arrays)
    if (Array.isArray(a)) {
        if (!Array.isArray(b) || a.length !== b.length) return false;
        return a.every((v, i) => $eq(v, b[i]));
    }

    // Record comparison
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    if (keysA.length !== keysB.length) return false;
    return keysA.every(k => $eq(a[k], b[k]));
};
```

**Usage notes:**
- The preamble is only emitted if the program uses features that require it
- `ref` is needed when mutable references are used
- `$eq` is needed when `==` or `!=` is used on composite types
- Future optimization: tree-shake unused helpers

---

## 12. Future Extensibility

### 12.1 Multiple Targets

Prepare for:
- `es2020` - Current baseline
- `es2022` - Top-level await, class fields
- `esnext` - Latest ECMAScript features

**Approach:** Use strategy pattern for target-specific code generation.

### 12.2 Source Maps

Requirements for future implementation:
- Track source locations through generation
- Build source map as code is emitted
- Output inline or external source map
- Map generated JS lines/columns to `.vf` source

**Preparation:** Preserve `loc` information, emit code with location tracking.

### 12.3 Runtime Type Checking

Three modes:
- `none` - No runtime checks (production)
- `ffi` - Check values crossing FFI boundary
- `all` - Check all operations (development)

**Preparation:** Identify FFI boundaries (external calls, unsafe blocks).

---

## 13. Testing Strategy

### 13.1 Unit Tests

- Test each expression type compilation
- Test each pattern type compilation
- Test each declaration type compilation
- Test identifier escaping
- Test operator precedence

### 13.2 Integration Tests

- End-to-end compilation of `.vf` programs
- Verify generated JS is syntactically valid (parse with Node)
- Verify generated JS executes correctly

### 13.3 Snapshot Tests

- Golden file tests for representative programs
- Compare generated output against expected

### 13.4 Semantic Tests

- Verify currying behavior
- Verify pattern matching semantics
- Verify short-circuit evaluation
- Verify mutable reference behavior

---

## 14. Acceptance Criteria

### 14.1 MVP Functional Requirements

1. All Core AST expression types compile correctly
2. All Core AST pattern types compile correctly
3. All Core AST declaration types compile correctly
4. Generated code is valid ES2020
5. Generated code executes correctly
6. Currying works (partial application)
7. Pattern matching with guards works
8. Short-circuit evaluation preserved
9. Mutable references work
10. External declarations work

### 14.2 MVP Non-Functional Requirements

1. Generated code is human-readable
2. No memory leaks in generated code
3. Reasonable code size (no excessive bloat)
4. Compiles in reasonable time

### 14.3 Integration Requirements

1. Integrates with existing CLI via `generate()` function
2. Accepts `TypedModule` from typechecker
3. Returns `GenerateResult` with `code` string
4. Handles `filename` option for comments

---

## 15. Critical Reference Files

| File | Purpose |
|------|---------|
| `packages/core/src/types/core-ast.ts` | Core AST node definitions |
| `packages/core/src/typechecker/typechecker.ts` | TypedModule interface |
| `packages/core/src/types/environment.ts` | TypeEnv structure |
| `packages/core/src/codegen/index.ts` | Current stub implementation |
| `packages/cli/src/commands/compile.ts` | CLI integration point |
| `docs/spec/12-compilation/codegen.md` | Language spec for codegen |

---

## 16. Design Decisions (Resolved)

The following design decisions were made during the requirements review:

### 16.1 Structural Equality

- **Decision:** Use `$eq` runtime helper for composite types
- **NaN:** Follows IEEE 754 (`NaN == NaN` is `false`)
- **Implementation:** See Section 11.6 for the `$eq` helper specification

### 16.2 Integer Division by Zero

- **Decision:** Follow JavaScript behavior (no exception)
- **Rationale:** Returns `Infinity`, `-Infinity`, or `NaN`. Users who need explicit error handling should check for zero before dividing.

### 16.3 ref() Handling

- **Decision:** Runtime preamble provides `const ref = ($value) => ({ $value })`
- **Rationale:** Simple and consistent. The `ref` function is included in the runtime preamble (Section 11.6).

### 16.4 Constructor Functions

- **Decision:** Generate constructor functions at type declaration, use in expressions
- **Example:** `CoreTypeDecl` for `Option<T>` generates `const Some = ($0) => ({ $tag: "Some", $0 })` and `const None = { $tag: "None" }`

### 16.5 Export Strategy

- **Decision:** Collected at end of file
- **Format:** `export { name1, name2, ... };` at bottom of generated file

### 16.6 Empty Tuple vs Unit

- **Decision:** `CoreUnitLit` → `undefined`, `CoreTuple` → array literal
- **Note:** Empty `CoreTuple { elements: [] }` should not occur from normal parsing. The parser produces `UnitLit` for `()`, which desugars to `CoreUnitLit`.

### 16.7 Record Spread in Updates

- **Decision:** Preserve spreads in JavaScript output using `...` syntax
- **Format:** `CoreRecordUpdate` with spreads emits `{ ...record, ...other, field: value }`

---

## Appendix A: Complete Core AST Node Reference

### Expressions (CoreExpr)

| Node Kind | Key Fields | Compilation |
|-----------|------------|-------------|
| `CoreIntLit` | `value: number` | Emit number literal |
| `CoreFloatLit` | `value: number` | Emit number literal |
| `CoreStringLit` | `value: string` | Emit escaped string |
| `CoreBoolLit` | `value: boolean` | Emit `true`/`false` |
| `CoreUnitLit` | - | Emit `undefined` |
| `CoreVar` | `name: string` | Emit identifier (escaped if reserved) |
| `CoreLet` | `pattern`, `value`, `body`, `mutable`, `recursive` | Emit binding + body |
| `CoreLetRecExpr` | `bindings[]`, `body` | Emit mutually recursive bindings |
| `CoreLambda` | `param: CorePattern`, `body` | Emit arrow function |
| `CoreApp` | `func`, `args[]` | Emit curried calls |
| `CoreMatch` | `expr`, `cases[]` | Emit IIFE with conditionals |
| `CoreRecord` | `fields[]` | Emit object literal |
| `CoreRecordAccess` | `record`, `field` | Emit `expr.field` |
| `CoreRecordUpdate` | `record`, `updates[]` | Emit spread + updates |
| `CoreVariant` | `constructor`, `args[]` | Emit constructor call or tagged object |
| `CoreBinOp` | `op`, `left`, `right` | Emit binary expression |
| `CoreUnaryOp` | `op`, `expr` | Emit unary expression |
| `CoreTypeAnnotation` | `expr`, `typeExpr` | Emit inner expression only |
| `CoreUnsafe` | `expr` | Emit inner expression only |
| `CoreTuple` | `elements[]` | Emit array literal |

### Patterns (CorePattern)

| Node Kind | Key Fields | Compilation |
|-----------|------------|-------------|
| `CoreWildcardPattern` | - | No test, no binding |
| `CoreVarPattern` | `name: string` | No test, bind to name |
| `CoreLiteralPattern` | `literal: number\|string\|boolean\|null` | Test with `===` |
| `CoreVariantPattern` | `constructor`, `args[]` | Test `$tag`, destructure `$0`, `$1`... |
| `CoreRecordPattern` | `fields[]` | Destructure named fields |
| `CoreTuplePattern` | `elements[]` | Destructure array indices |

### Declarations (CoreDeclaration)

| Node Kind | Key Fields | Compilation |
|-----------|------------|-------------|
| `CoreLetDecl` | `pattern`, `value`, `mutable`, `recursive`, `exported` | Emit `const` binding |
| `CoreLetRecGroup` | `bindings[]`, `exported` | Emit mutually recursive bindings |
| `CoreTypeDecl` | `name`, `params`, `definition`, `exported` | Emit constructor functions (variants only) |
| `CoreExternalDecl` | `name`, `jsName`, `from?`, `exported` | Emit import + const binding |
| `CoreExternalTypeDecl` | `name`, `typeExpr`, `exported` | No runtime code |
| `CoreImportDecl` | `items[]`, `from` | Emit ES6 import |

### Supporting Types

| Type | Fields | Notes |
|------|--------|-------|
| `CoreRecordField` | `kind: "Field"\|"Spread"`, `name?`, `value`/`expr` | For record construction |
| `CoreMatchCase` | `pattern`, `guard?`, `body` | Guard is optional |
| `CoreImportItem` | `name`, `alias?`, `isType` | Type-only imports are filtered |

---

## Appendix B: JavaScript Reserved Words

These must be escaped when used as vibefun identifiers:

**Keywords:**
`break`, `case`, `catch`, `class`, `const`, `continue`, `debugger`, `default`, `delete`, `do`, `else`, `enum`, `export`, `extends`, `false`, `finally`, `for`, `function`, `if`, `import`, `in`, `instanceof`, `new`, `null`, `return`, `super`, `switch`, `this`, `throw`, `true`, `try`, `typeof`, `var`, `void`, `while`, `with`, `yield`

**Strict mode reserved:**
`implements`, `interface`, `let`, `package`, `private`, `protected`, `public`, `static`

**Future reserved:**
`await`

**Escaping strategy:** Append `$` to create valid identifier: `class` → `class$`

---

## Appendix C: Compiler-Generated Names

Names starting with `$` are reserved for compiler use:

| Pattern | Usage |
|---------|-------|
| `$tag` | Variant tag property |
| `$0`, `$1`, ... | Variant constructor arguments |
| `$value` | Ref value property |
| `$match` | Match scrutinee temporary |
| `$ext_*` | External import bindings |
| `$eq` | Structural equality helper |
| `$temp_*` | Temporary variables |

User code should not use `$`-prefixed identifiers.

---

## Appendix D: Implementation Checklist

Use this checklist to verify completeness of the code generator:

### Core Expression Types
- [ ] `CoreIntLit` - Integer literals (including negative)
- [ ] `CoreFloatLit` - Float literals (including Infinity, NaN)
- [ ] `CoreStringLit` - String literals with proper escaping
- [ ] `CoreBoolLit` - Boolean literals
- [ ] `CoreUnitLit` - Unit literal
- [ ] `CoreVar` - Variable references (with reserved word escaping)
- [ ] `CoreLet` - Let bindings (with patterns, mutable, recursive flags)
- [ ] `CoreLetRecExpr` - Mutually recursive bindings
- [ ] `CoreLambda` - Lambda expressions (single param)
- [ ] `CoreApp` - Function application (multi-arg currying)
- [ ] `CoreMatch` - Match expressions with guards
- [ ] `CoreRecord` - Record literals (with spreads)
- [ ] `CoreRecordAccess` - Field access
- [ ] `CoreRecordUpdate` - Record update
- [ ] `CoreVariant` - Variant construction
- [ ] `CoreBinOp` - All binary operators
- [ ] `CoreUnaryOp` - All unary operators
- [ ] `CoreTypeAnnotation` - Type annotation (erased)
- [ ] `CoreUnsafe` - Unsafe block (erased)
- [ ] `CoreTuple` - Tuple expressions

### Pattern Types
- [ ] `CoreWildcardPattern` - Wildcard pattern
- [ ] `CoreVarPattern` - Variable binding pattern
- [ ] `CoreLiteralPattern` - Literal matching (number, string, boolean, null)
- [ ] `CoreVariantPattern` - Variant destructuring
- [ ] `CoreRecordPattern` - Record destructuring
- [ ] `CoreTuplePattern` - Tuple destructuring
- [ ] Nested patterns
- [ ] Guard expressions

### Declaration Types
- [ ] `CoreLetDecl` - Top-level let declarations
- [ ] `CoreLetRecGroup` - Mutually recursive declaration groups
- [ ] `CoreTypeDecl` - Type declarations (variant constructors)
- [ ] `CoreExternalDecl` - External value declarations
- [ ] `CoreExternalTypeDecl` - External type declarations (no output)
- [ ] `CoreImportDecl` - Import declarations

### Infrastructure
- [ ] Header comment generation
- [ ] Import collection and emission
- [ ] Export collection and emission
- [ ] Identifier escaping
- [ ] Operator precedence handling
- [ ] Proper parenthesization
- [ ] Statement vs expression context handling
- [ ] Semicolon insertion
- [ ] Indentation management

### Testing Coverage
- [ ] Unit tests for each expression type
- [ ] Unit tests for each pattern type
- [ ] Unit tests for each declaration type
- [ ] Integration tests (end-to-end compilation)
- [ ] Semantic tests (currying, short-circuit, etc.)
- [ ] Snapshot/golden tests for representative programs
