# Parser Snapshot Testing Plan

**Created**: 2025-11-22
**Status**: Ready to implement

## Overview

Create comprehensive snapshot tests for the vibefun parser using realistic code samples that exercise multiple features together. Tests will complement existing unit tests by capturing end-to-end parser behavior with idiomatic vibefun code.

## Objectives

1. Create snapshot tests using realistic .vf code files (20-50 lines each)
2. Organize tests by feature category for clear coverage
3. Generate formatted JSON snapshots of AST output
4. Ensure tests fail when parser output changes unexpectedly
5. Provide clear documentation for snapshot maintenance

## Structure

### Directory Layout
```
packages/core/src/parser/snapshot-tests/
├── fixtures/                    # .vf source files
│   ├── declarations.vf
│   ├── expressions.vf
│   ├── patterns.vf
│   ├── functions.vf
│   ├── data-structures.vf
│   ├── control-flow.vf
│   ├── modules.vf
│   └── real-world.vf
├── __snapshots__/              # Generated by vitest
│   └── snapshot-tests.test.ts.snap
├── snapshot-tests.test.ts      # Test runner
└── CLAUDE.md                   # Snapshot maintenance guide
```

## Test Categories

### 1. Declarations (declarations.vf)
**Focus**: Top-level declarations with various modifiers and combinations

Sample features:
- Mutually recursive functions with `rec` and `and`
- Mutually recursive types
- External blocks with `from` clause
- External type declarations
- Export modifiers
- Pattern destructuring in let bindings

**Example pattern**:
```vibefun
let rec isEven = (n) => if n == 0 then true else isOdd(n - 1)
and isOdd = (n) => if n == 0 then false else isEven(n - 1);

type Expr = Lit(Int) | Add(Expr, Expr)
and Pattern = VarPat(String) | LitPat(Int);

external from "fs" {
    type File = JsObject;
    readFile: (String) -> Promise<String> = "readFile";
};
```

### 2. Expressions (expressions.vf)
**Focus**: Complex expression combinations with operators and precedence

Sample features:
- Pipeline chains with lambdas
- Nested operators across precedence levels
- Complex type annotations on expressions
- Record updates with computed fields
- Nested match expressions
- Composition operators

**Example pattern**:
```vibefun
[1, 2, 3, 4, 5]
    |> List.filter((x) => x % 2 == 0)
    |> List.map((x) => x * x)
    |> List.fold(0, (acc, x) => acc + x);

let updated = {
    ...person,
    status: match age {
        | n when n < 18 => "minor"
        | n when n < 65 => "adult"
        | _ => "senior"
    }
};
```

### 3. Patterns (patterns.vf)
**Focus**: Pattern matching with destructuring and guards

Sample features:
- Nested destructuring in match cases
- Or-patterns with multiple alternatives
- Pattern guards with complex expressions
- List patterns with rest syntax
- Record patterns with renaming
- Tuple patterns

**Example pattern**:
```vibefun
match result {
    | Ok({ user: { name, email }, session: Some(token) }) when isValid(token) =>
        login(name, email, token)
    | Ok({ user: { name }, session: None }) =>
        requireAuth(name)
    | Err(NotFound) | Err(Unauthorized) =>
        redirect("/login")
    | Err(e) =>
        logError(e)
};
```

### 4. Functions (functions.vf)
**Focus**: Function definitions and higher-order programming

Sample features:
- Higher-order functions with generics
- Currying and partial application
- Recursive functions with pattern matching
- Function composition
- Type-annotated function signatures

**Example pattern**:
```vibefun
export let compose: <A, B, C>((B) -> C) -> ((A) -> B) -> (A) -> C =
    (f) => (g) => (x) => f(g(x));

let rec map = (f, list) => match list {
    | [] => []
    | [head, ...tail] => [f(head), ...map(f, tail)]
};
```

### 5. Data Structures (data-structures.vf)
**Focus**: Complex data structure construction

Sample features:
- Deeply nested records
- Multiple spread operators
- Record updates with nesting
- Lists with multiple spreads
- Mixed literals and spreads
- Trailing commas

**Example pattern**:
```vibefun
let config = {
    ...defaults,
    server: {
        ...defaultServer,
        ssl: {
            enabled: true,
            cert: "/path/to/cert",
            ...sslOverrides
        }
    },
    database: { ...defaultDb, pool: { min: 2, max: 10 } }
};
```

### 6. Control Flow (control-flow.vf)
**Focus**: Control flow constructs and blocks

Sample features:
- While loops with mutable refs
- Nested if-match-block combinations
- Blocks with multiple statements
- Let expressions in blocks
- Complex conditionals

**Example pattern**:
```vibefun
let mut count = ref(0);
while count! < 10 {
    count := count! + 1;
    process(count!);
};

if isValid(input) then {
    let parsed = parse(input);
    match validate(parsed) {
        | Ok(data) => { let result = process(data); save(result); result; }
        | Err(e) => { logError(e); defaultValue; }
    };
} else defaultValue
```

### 7. Modules (modules.vf)
**Focus**: Complete module structure with all declaration types

Sample features:
- Import declarations (named, namespace, type)
- Export modifiers
- Type declarations
- Function definitions
- External declarations
- Complete realistic module

**Example pattern**:
```vibefun
import { Option, Some, None } from "vibefun/std";
import * as List from "./list";

export type User = { id: Int, name: String, email: String };
type Result<T, E> = Ok(T) | Err(E);

export let findUser = (id, users) =>
    List.find(users, (user) => user.id == id);

external from "database" {
    type Connection = JsObject;
    connect: (String) -> Promise<Connection> = "connect";
};
```

### 8. Real World (real-world.vf)
**Focus**: Idiomatic vibefun patterns from stdlib

Sample features:
- Option/Result combinators
- List operations (map, fold, filter)
- Typical functional patterns
- Well-typed generic functions
- Pattern matching on ADTs

**Example pattern**:
```vibefun
export let mapOption = <A, B>(opt: Option<A>, f: (A) -> B): Option<B> =>
    match opt {
        | Some(x) => Some(f(x))
        | None => None
    };

export let rec fold = <A, B>(list: List<A>, init: B, f: (B, A) -> B): B =>
    match list {
        | [] => init
        | [head, ...tail] => fold(tail, f(init, head), f)
    };
```

## Test Implementation

### Test Runner Structure
```typescript
import { describe, expect, it } from "vitest";
import { readFileSync } from "fs";
import { Lexer } from "../lexer/index.js";
import { Parser } from "./parser.js";

function parseSnapshot(filename: string) {
    const source = readFileSync(
        `./src/parser/snapshot-tests/fixtures/${filename}`,
        "utf-8"
    );
    const lexer = new Lexer(source, filename);
    const tokens = lexer.tokenize();
    const parser = new Parser(tokens, filename);
    return parser.parse();
}

describe("Parser Snapshots - Declarations", () => {
    it("should parse declarations.vf", () => {
        const ast = parseSnapshot("declarations.vf");
        expect(ast).toMatchSnapshot();
    });
});
```

### Snapshot Format
- Vitest automatically generates formatted JSON snapshots
- Snapshots saved to `__snapshots__/snapshot-tests.test.ts.snap`
- Human-readable formatting for easy review
- Git-committed for version control

## Coverage Goals

- **80-120 total snapshots**: ~10-15 per category
- **Representative samples**: Cover all major parser features
- **Realistic code**: What developers would actually write
- **Edge cases**: Deep nesting, complex precedence, multiple spreads
- **Spec compliance**: Validate parser matches language specification

## Documentation Requirements

### CLAUDE.md Contents
Must include:
1. **Critical Warning**: Review failing tests carefully before updating snapshots
2. **Update Commands**: How to run `npm test -- -u` for snapshot updates
3. **Review Guidelines**: How to examine AST diffs and determine if changes are expected
4. **When to Reject**: Criteria for rejecting snapshot updates (unexpected structural changes)
5. **Maintenance**: How to add new snapshot tests

## Success Criteria

1. ✅ All 8 fixture files created with realistic vibefun code
2. ✅ Test runner successfully parses all fixtures
3. ✅ Snapshots generated and committed
4. ✅ Tests fail when parser output changes
5. ✅ CLAUDE.md provides clear maintenance guidance
6. ✅ Coverage complements existing unit tests

## Implementation Notes

- Each .vf file should be self-contained and runnable (when type checker exists)
- Code samples should demonstrate best practices and idiomatic vibefun
- Snapshots serve as AST documentation for developers
- Balance between comprehensive coverage and maintainability
- Prioritize common patterns over exhaustive edge case testing
